<h2>Тестовое задание для компании Эмбедика (Справочник автомобилей) </h2>

Из дополнительных пунктов я сделал:

 - Сохранение запросов к сервису и вывод лога в api
 - Статистика запросов к сервису (сколько, время обработки и прочее)
 - Кэширование запросов
 - Docker файл для развертывания сервиса
 - Unit тесты
 - GraphQL для API
 
 
<h3> Логи и запросы </h3>

Логи я храню в базе в таблице requests, когда нужно сделать "вывод лога в api", я вывожу всё, что есть в этой таблице. Каждый http-запрос к сервису обрабатывается, и если он успешен, то в базу сохраняется url, startProcessingAt (время получения запроса), endProcessingAt (время ответа).

Статистика запросов к сервису - выводится url, количество запросов к этому url и максимальное время обработки (вывожу в миллисекундах для удобства)

<h3> Кэширование запросов </h3>

Я решил использовать redis для кеширования - туда будут сохраняться статистика к базе и фильтры по машинам, у фильтров по машинам есть ttl, равный 5 минутам, если обращаемся и получаем из кеша данные, мы обновляем ttl по ключу, если удаляем или создаём машину, то удаляем кеш (потому что данные недействительные). У статистики к базе ttl не ставится.

<h3> Docker файл для развертывания сервиса </h3>

Есть 3 контейнера

  - app (с приложением, собранным через Dockerfile)
  - cache (redis)
  - postgres (файл init.sql лежит в project/migrations)

Запускать проект так

    docker-compose up
    
Само приложение будет работать по адресу http://localhost:3000

<h3> Unit-тесты </h3>

Написал тесты для CarService и LogService, запускать так

    sbt run test

<h3> GraphQL для API </h3>

Доступны все те же данные, но запросы GraphQL не сохраняются в таблицу requests.

<h2> Описание API </h2>

 - GET => /api/logs - выводит лог
 - GET => /api/logs/stats - выводит статистику по логу
 - GET => /api/cars - выводит отфильтрованные машины, параметры фильтрации такие - number, stamp (марка), color, yearFrom, yearTo (можно фильтровать по году выпуска), параметры опциональные
 - POST => /api/cars/create - создает машину, нужно передать json с параметрами машины кроме id (он автоинкрементируется) с параметрами number, stamp (марка), color, yearOfRelease, вернёт кастомную ошибку, если number уже существует (он уникальный)
 - POST => /api/cars/delete - удаляет машину, нужно передать id машины (например, /cars/delete?id=1), вернёт кастомную ошибку, если не найдет такой id
 - GET => /graphql/schema - выводит сгенерированные GraphQL типы
 - POST => /graphql - туда слать GraphQL запросы (например, я слал через Postman)

<h2> Что использовал из библиотек </h2>

- cats/cats-effect
- http4s
- circe (для работы с json)
- doobie (для работы с базой Postgresql)
- caliban (это GraphQL библиотека)
- newtype
- redis4cats
- ScalaTest

<h2> Описание архитектуры приложения </h2>

- в папке bootstrap содержатся классы для сборки приложения
- в папке caliban находятся типы GraphQL и разные имплиситы для запросов и мутаций
- в папке circe хранятся имплиситные декодеры и энкодеры, а также имплиситы для doobie
- в папке config содержится описание конфигов
- в папке domain содержатся основные сущности для работы в приложении
- в папке dsls содержатся трейты
- в папке routes хранятся классы с роутами от http4s, туда передаются сервисы для описания логики работы роутов
- в папке services хранятся классы, описывающие логику работы с данными
- в папке storages хранятся классы для работы с данными


